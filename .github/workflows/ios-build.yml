name: iOS Ad Hoc Build

on:
  push:
    branches: ["main"]
  pull_request:
  workflow_dispatch:

jobs:
  build-sign-export:
    name: Build, Sign, and Export Ad Hoc IPA
    runs-on: macos-latest
    env:
      SCHEME: YourAppScheme
      CONFIGURATION: Release
      ARCHIVE_PATH: ${{ github.workspace }}/build/ios/YourAppScheme.xcarchive
      EXPORT_PATH: ${{ github.workspace }}/build/ios/export
      EXPORT_OPTIONS_PATH: ${{ github.workspace }}/build/ios/exportOptions.plist
      KEYCHAIN_PATH: ${{ runner.temp }}/ios-build.keychain-db
      P12_BASE64: ${{ secrets.P12_BASE64 }}
      P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      TEAM_ID: ${{ secrets.TEAM_ID }}
      PROFILE_UUID: ${{ secrets.PROFILE_UUID }}
      BUNDLE_ID_PREFIX: ${{ secrets.BUNDLE_ID_PREFIX }}
      BUNDLE_ID_SUFFIX: ${{ secrets.BUNDLE_ID_SUFFIX }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Resolve bundle identifier
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${BUNDLE_ID_PREFIX:-}" ] || [ -z "${BUNDLE_ID_SUFFIX:-}" ]; then
            echo "::error::BUNDLE_ID_PREFIX and BUNDLE_ID_SUFFIX secrets must be provided." >&2
            exit 1
          fi
          RESOLVED_BUNDLE_ID="${BUNDLE_ID_PREFIX}.${BUNDLE_ID_SUFFIX}"
          echo "RESOLVED_BUNDLE_ID=${RESOLVED_BUNDLE_ID}" >> "${GITHUB_ENV}"
          echo "Using bundle identifier: ${RESOLVED_BUNDLE_ID}"

      - name: Decode signing assets
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${P12_BASE64:-}" ]; then
            echo "::error::P12_BASE64 secret is required." >&2
            exit 1
          fi
          if [ -z "${MOBILEPROVISION_BASE64:-}" ]; then
            echo "::error::MOBILEPROVISION_BASE64 secret is required." >&2
            exit 1
          fi
          mkdir -p signing
          python3 - <<'PY'
import base64
import os
from pathlib import Path

cert_data = os.environ["P12_BASE64"].encode()
profile_data = os.environ["MOBILEPROVISION_BASE64"].encode()
Path("signing").mkdir(parents=True, exist_ok=True)
Path("signing/cert.p12").write_bytes(base64.b64decode(cert_data))
Path("signing/profile.mobileprovision").write_bytes(base64.b64decode(profile_data))
PY
          echo "Decoded signing assets into the signing/ directory."
          echo "SHA256 (cert.p12):"
          shasum -a 256 signing/cert.p12
          echo "SHA256 (profile.mobileprovision):"
          shasum -a 256 signing/profile.mobileprovision

      - name: Configure temporary keychain
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${KEYCHAIN_PASSWORD:-}" ]; then
            echo "::error::KEYCHAIN_PASSWORD secret is required." >&2
            exit 1
          fi
          if [ -z "${P12_PASSWORD:-}" ]; then
            echo "::error::P12_PASSWORD secret is required." >&2
            exit 1
          fi
          ORIGINAL_KEYCHAINS_FILE="${RUNNER_TEMP}/original-keychains.list"
          security list-keychains -d user > "${ORIGINAL_KEYCHAINS_FILE}"
          echo "ORIGINAL_KEYCHAINS_FILE=${ORIGINAL_KEYCHAINS_FILE}" >> "${GITHUB_ENV}"

          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security set-keychain-settings -lut 21600 "${KEYCHAIN_PATH}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security list-keychains -d user -s "${KEYCHAIN_PATH}" $(tr -d '"' < "${ORIGINAL_KEYCHAINS_FILE}")
          security default-keychain -d user -s "${KEYCHAIN_PATH}"
          security import signing/cert.p12 -k "${KEYCHAIN_PATH}" -P "${P12_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/security -A
          security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          echo "Temporary keychain ready at ${KEYCHAIN_PATH}"

      - name: Install provisioning profile
        shell: bash
        run: |
          set -euo pipefail
          PROFILE_DIR="${HOME}/Library/MobileDevice/Provisioning Profiles"
          PROFILE_INSTALL_PATH="${PROFILE_DIR}/${PROFILE_UUID}.mobileprovision"
          mkdir -p "${PROFILE_DIR}"
          cp signing/profile.mobileprovision "${PROFILE_INSTALL_PATH}"
          echo "Installed provisioning profile at ${PROFILE_INSTALL_PATH}"
          echo "Provisioning profile UUID: ${PROFILE_UUID}"
          echo "Provisioning profile Team ID: ${TEAM_ID}"
          echo "Installed profile SHA256:"
          shasum -a 256 "${PROFILE_INSTALL_PATH}"

      - name: Generate export options plist
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${RESOLVED_BUNDLE_ID:-}" ]; then
            echo "::error::Resolved bundle identifier is unavailable." >&2
            exit 1
          fi
          mkdir -p "$(dirname "${EXPORT_OPTIONS_PATH}")"
          cat <<PLIST > "${EXPORT_OPTIONS_PATH}"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>method</key>
  <string>ad-hoc</string>
  <key>signingStyle</key>
  <string>manual</string>
  <key>provisioningProfiles</key>
  <dict>
    <key>${RESOLVED_BUNDLE_ID}</key>
    <string>${PROFILE_UUID}</string>
  </dict>
  <key>teamID</key>
  <string>${TEAM_ID}</string>
  <key>stripSwiftSymbols</key>
  <true/>
  <key>compileBitcode</key>
  <false/>
</dict>
</plist>
PLIST
          echo "exportOptions.plist created at ${EXPORT_OPTIONS_PATH}"
          cat "${EXPORT_OPTIONS_PATH}"

      - name: Archive app
        shell: bash
        working-directory: wifi-handshake-c
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${ARCHIVE_PATH}")"
          IOS_PROJECT_DIR="ios"
          declare -a BUILD_DEST_ARG
          if compgen -G "${IOS_PROJECT_DIR}/*.xcworkspace" > /dev/null; then
            WORKSPACE_PATH=$(ls "${IOS_PROJECT_DIR}"/*.xcworkspace | head -n 1)
            BUILD_DEST_ARG=(-workspace "${WORKSPACE_PATH}")
            echo "Detected workspace: ${WORKSPACE_PATH}"
          elif compgen -G "${IOS_PROJECT_DIR}/*.xcodeproj" > /dev/null; then
            PROJECT_PATH=$(ls "${IOS_PROJECT_DIR}"/*.xcodeproj | head -n 1)
            BUILD_DEST_ARG=(-project "${PROJECT_PATH}")
            echo "Detected project: ${PROJECT_PATH}"
          else
            echo "::error::No Xcode workspace or project found under ${IOS_PROJECT_DIR}" >&2
            exit 1
          fi

          echo "Starting archive build for scheme ${SCHEME} (configuration: ${CONFIGURATION})"
          xcodebuild "${BUILD_DEST_ARG[@]}" \
            -scheme "${SCHEME}" \
            -configuration "${CONFIGURATION}" \
            -archivePath "${ARCHIVE_PATH}" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="${RESOLVED_BUNDLE_ID}" \
            PROVISIONING_PROFILE_SPECIFIER="${PROFILE_UUID}" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            archive

          echo "Archive completed at ${ARCHIVE_PATH}"
          ls "${ARCHIVE_PATH}"

      - name: Export IPA
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${EXPORT_PATH}"
          echo "Exporting IPA to ${EXPORT_PATH} using ${EXPORT_OPTIONS_PATH}"
          env OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            xcodebuild -exportArchive \
            -archivePath "${ARCHIVE_PATH}" \
            -exportPath "${EXPORT_PATH}" \
            -exportOptionsPlist "${EXPORT_OPTIONS_PATH}"
          echo "Export complete. Generated files:"
          find "${EXPORT_PATH}" -maxdepth 1 -type f -print

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-ad-hoc-build
          path: ${{ env.EXPORT_PATH }}
          if-no-files-found: error

      - name: Cleanup keychain
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${ORIGINAL_KEYCHAINS_FILE:-}" ] && [ -f "${ORIGINAL_KEYCHAINS_FILE}" ]; then
            security list-keychains -d user -s $(tr -d '"' < "${ORIGINAL_KEYCHAINS_FILE}")
            rm -f "${ORIGINAL_KEYCHAINS_FILE}" || true
          fi
          security default-keychain -d user -s login.keychain-db || \
            security default-keychain -d user -s login.keychain || true
          security delete-keychain "${KEYCHAIN_PATH}" || true
          echo "Temporary keychain cleaned up."
